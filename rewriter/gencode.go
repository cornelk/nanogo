package rewriter

import (
	"fmt"
	"go/ast"
	"go/printer"
	"go/token"
	"io"
)

// GenCode generates Go code for a set of rules
func GenCode(rules []*Rule, name, pkg, matcher, builder string, out io.Writer) {
	fmt.Fprintln(out, "// Code generated by rewriter; DO NOT EDIT.")
	fmt.Fprintln(out, "package", pkg)
	fmt.Fprintln(out, "")
	fmt.Fprintf(out, "func %s(it *%s, b *%s) ", name, matcher, builder)
	printer.Fprint(out, token.NewFileSet(), GenRuleCodeBlocks(rules))
}

// GenRuleCodeBlocks generates go/ast nodes for each rule.
// See the tests for a more human readable description of how this works, since
// building ast nodes doesn't lead to the most clear code.
func GenRuleCodeBlocks(rules []*Rule) *ast.BlockStmt {
	blk := &ast.BlockStmt{}
	for _, rule := range rules {
		blk.List = append(blk.List, genRuleCode(rule))
	}
	return blk
}

func genRuleCode(rule *Rule) *ast.BlockStmt {
	blk := &ast.BlockStmt{}
	switch rule.From.Kind {
	case Call:
		stmt, stmtBody := (&nested{}).matchIfStmt("it", rule.From)

		replace := &ast.CallExpr{}
		replace.Fun = &ast.SelectorExpr{
			X:   &ast.Ident{Name: "it"},
			Sel: &ast.Ident{Name: "Replace"},
		}

		switch rule.To.Kind {
		case Nil:
			replace.Fun.(*ast.SelectorExpr).Sel.Name = "Remove"

			stmtBody.List = append(stmtBody.List, &ast.ExprStmt{
				X: replace,
			})
		case Ident:
			replace.Args = append(replace.Args, &ast.Ident{Name: rule.To.Name})

			stmtBody.List = append(stmtBody.List, &ast.ExprStmt{
				X: replace,
			})
		case Call:
			call := &ast.CallExpr{}
			call.Fun = &ast.SelectorExpr{
				X:   &ast.Ident{Name: "b"},
				Sel: &ast.Ident{Name: rule.To.Name},
			}

			for _, arg := range rule.To.Args {
				switch arg.Kind {
				case Ident:
					call.Args = append(call.Args, &ast.Ident{Name: arg.Name})
				}
			}

			replace.Args = append(replace.Args, call)

			stmtBody.List = append(stmtBody.List, &ast.ExprStmt{
				X: replace,
			})
		}

		blk.List = append(blk.List, stmt)
	}
	return blk
}

type nested struct {
	temp int
}

func (n *nested) matchIfStmt(root string, lhs *Node) (*ast.IfStmt, *ast.BlockStmt) {
	stmt := &ast.IfStmt{}
	body := &ast.BlockStmt{}
	stmt.Body = body

	assign := &ast.AssignStmt{}

	call := &ast.CallExpr{}
	call.Fun = &ast.SelectorExpr{
		X:   &ast.Ident{Name: root},
		Sel: &ast.Ident{Name: lhs.Name},
	}

	assign.Tok = token.DEFINE

	for _, arg := range lhs.Args {
		switch arg.Kind {
		case Ident:
			assign.Lhs = append(assign.Lhs, &ast.Ident{Name: arg.Name})
		case Call:
			tVar := fmt.Sprintf("t%d", n.temp)
			n.temp++
			assign.Lhs = append(assign.Lhs, &ast.Ident{Name: tVar})
			inner, innerBody := n.matchIfStmt(tVar, arg)
			body.List = append(body.List, inner)
			body = innerBody
		}
	}

	assign.Lhs = append(assign.Lhs, &ast.Ident{Name: "ok"})
	assign.Rhs = append(assign.Rhs, call)

	stmt.Init = assign

	stmt.Cond = &ast.Ident{Name: "ok"}

	return stmt, body
}
